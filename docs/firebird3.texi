
\input texinfo
@settitle Nimized Firebird 3

@ifnottex
@node Top
@top

@end ifnottex

@node Database connections
@chapter Database connections

@quotation Note
It is possible to use Pascal-style string handling, where a pointer to text and a given length of the text is passed to this function. Presently that method has been wrapped over, enforcing the use of cstrings. A ``proper'' version which accepts native Nim strings might be possible.
@end quotation

@deftypefn Proc ISC_STATUS isc_attach_database @var{status_vector}: ref ISC_STATUS_ARRAY; @var{db_name}: cstring; @var{db}: ref isc_db_handle; @var{parm_buffer_length}: cshort = 0; @var{parm_buffer}: cstring = nil

Attaches a new database.

@table @code
@item status
Error status vector.

@item db_name
Name of the database to attach.

@item db
Handle; will be overriden to either @code{NULL} on error, or the handle to the attached database on success.

@item parm_buffer_length
Length of the database parameter buffer.

@item parm_buffer
A specially constructed string, which acts as a set of parameters for the database. Connection information such as the username and password to connect with are specified here.
@end table

@cite{http://docwiki.embarcadero.com/InterBase/XE7/en/Isc_attach_database()}

@end deftypefn

@deftypefn Proc ISC_STATUS isc_detach_database @var{status}: ref ISC_STATUS, @var{db}: ref isc_db_handle)

Releases a previously attached database.

@table @code
@item status
Error status vector.

@item db
Handle to the database to be freed.

@end table

@cite{http://docwiki.embarcadero.com/InterBase/XE7/en/Isc_detach_database()}

@end deftypefn

@node Transactions
@chapter Transactions

@deftypefn Proc ISC_STATUS isc_start_transaction status: ref ISC_STATUS_ARRAY; transaction: ref isc_tr_handle; db: var isc_db_handle; tpb_length: cushort; tpb: cstring

Starts a new transaction, storing a handle to the transaction within @var{transaction}. The database in question is specified with the handle @var{db}. If a transaction parameter buffer is used, its length and string are supplied. The nimized version of this function defaults both transaction parameter buffer options to nil.

@quotation Note
Firebird supports transactions against multiple open databases; the API for doing this in a Nim-supported way is a little hairy, so it was (for now) simplified to a call that works on a single database.
@end quotation

@cite{http://docwiki.embarcadero.com/InterBase/XE7/en/Isc_start_transaction()}
@end deftypefn

@deftypefn Proc ISC_STATUS isc_rollback_transaction status: ref ISC_STATUS_ARRAY, transaction: ref isc_tr_handle

Aborts a transaction; any changes that would have been made inside of it are not made. The database remains unchanged.
@end deftypefn

@anchor{isc_commit_transaction}
@deftypefn Proc ISC_STATUS isc_commit_transaction status: var ISC_STATUS_ARRAY; tr: var isc_tr_handle

Commits a transaction; any changes that would have been made inside of it are now made if possible.  Should an error occur while trying to commit any data, @emph{none} of the changes will be made.
@end deftypefn

@node Running queries
@chapter Running queries

@anchor{Immediate Queries}
@section Immediate Queries

An immediate query is one where its @dfn{statement} is prepared, executed, and deleted, in one call. A query which is run very infrequently or prepares a database might be run immediately. For queries that are going to be run many times within an application's lifecycle, refer to @ref{Prepared Queries}.  Immediate queries also do not allow values to be @dfn{bound} to placeholders and so are unsuitable for any query which accepts information from untrusted sources.

@quotation Note
An immediate query only means a statement is not prepared in advance. It does @emph{not} mean the statement bypasses any pending transactions.
@end quotation

@deftypefn Proc ISC_STATUS isc_dsql_execute_immediate status: var ISC_STATUS_ARRAY; db: var isc_db_handle; transaction: var isc_tr_handle; query: cstring; dialect: cushort = SQL_DIALECT_CURRENT; xsql: ptr XSQLDA = nil

Runs a statement that does not return data.

If running a @code{CREATE DATABASE} query, @var{db} and @var{transaction} should initially be zero. A handle to the new database is written to @var{db}, and a new transaction is started whom's handle is written to @var{transaction}. You must commit the transaction to finish creating the database. @xref{isc_commit_transaction}

@cite{http://docwiki.embarcadero.com/InterBase/XE7/en/Isc_dsql_execute_immediate()}
@end deftypefn

@deftypefn Proc ISC_STATUS isc_dsql_exec_immed2 status: var ISC_STATUS_ARRAY; db: var isc_db_handle; transaction: var isc_tr_handle; statement_length: cushort; statement: cstring; dialect: cushort = SQL_DIALECT_CURRENT; inx, outx: ptr XSQLDA = nil

Runs a statement which returns no more than a single row of results.

@cite{http://docwiki.embarcadero.com/InterBase/XE7/en/Isc_dsql_exec_immed2()}
@end deftypefn

@anchor{Prepared Queries}
@section Prepared Queries

@subsection Lifecycle

@deftypefn Proc ISC_STATUS isc_dsql_allocate_statement status: ref ISC_STATUS_ARRAY; db: ref isc_db_handle; statement: var isc_stmt_handle; autofree: bool = true

Allocates a handle for a prepared statement. @var{autofree} statements are cleaned up when their database is detached, otherwise you must clean up the handle manually.

@cite{http://docwiki.embarcadero.com/InterBase/XE7/en/Isc_dsql_allocate_statement()}@sp 0
@cite{http://docwiki.embarcadero.com/InterBase/XE7/en/Isc_dsql_alloc_statement2()}
@end deftypefn

@deftypefn Proc ISC_STATUS isc_dsql_free_statement status: ref ISC_STATUS_ARRAY; statement: var isc_stmt_handle; on_free: StatementFreeType

Explicitly frees a previously allocated statement.  Not necessary for statements created with @var{autofree = true}.

@table @code
@item status
Error status vector.

@item statement
A handle to the statement you want freed.

@item on_free
Action to handle when freeing the statement.  May be one of the following:

@table @code
@item DSQL_close
Closes any open cursors using this statement.  The handle and statement remain valid and prepared for future use.

@item DSQL_unprepare
Closes any open cursors using this statement, and removes the statement from the handle.  The handle remains valid and may have another statement prepared with it.

@item DSQL_drop
Like unprepare, but the handle is destroyed after the statement is unprepared.

@end table

@end table

@cite{https://stackoverflow.com/questions/35924822/firebird-c-client-api-statement-transaction-and-cursor-lifecycle#35956754}

@end deftypefn

@subsection Preparation

@anchor{isc_dsql_prepare}
@deftypefn Proc ISC_STATUS isc_dsql_prepare status: var ISC_STATUS_ARRAY; transaction: var isc_tr_handle; statement_handle: var isc_stmt_handle; statement: cstring; dialect: cushort = SQL_DIALECT_CURRENT; xsql: ptr XSQLDA = nil
@end deftypefn

Statements may contain placeholders, which are specified with the @code{?} (question mark) character.  Use of placeholders prevents SQL injection attacks.  To use placeholders, you must prepare an @code{XSQLDA} object to contain the values which are going in to the placeholder's positions.  For example the following:

@example
isc_dsql_prepare(status, transaction, statement,
  "INSERT INTO things VALUES(bees=?)")
@end example

Prepares a statement with a single placeholder: the value assigned to the @samp{bees} column of the new row.  You must then create an XSQLDA with a single variable; whatever this variable is assigned to, is whatever value is (safely) inserted where the first question mark goes.  Multiple question marks are allowed and are numbered sequentially.

@subsection Describing

Firebird can analyze a prepared statement and return information about either the values which will be returned from a @code{SELECT} statement, or the placeholders for an @code{INSERT} statement.

@deftypefn Proc ISC_STATUS isc_dsql_describe status: ref ISC_STATUS_ARRAY; statement: var isc_stmt_handle; dialect: cushort = SQL_DIALECT_CURRENT; outx: ptr XSQLDA
Analyzes the prepared @var{statement}, and stores the necessary variable definitions for data coming out of the database in @var{outx}.

@cite{Firebird 3.0's example/api/api4.c file}
@end deftypefn

@deftypefn Proc ISC_STATUS isc_dsql_describe_bind(status: ref ISC_STATUS_ARRAY; statement: var isc_stmt_handle; dialect: cushort = SQL_DIALECT_CURRENT; inx: ptr XSQLDA)
Analyzes the prepared @var{statement}, and stores the necessary variable definitions for data going from the program to the query's placeholders in @var{inx}.

@cite{http://docwiki.embarcadero.com/InterBase/XE7/en/Isc_dsql_describe_bind()}
@end deftypefn

@subsection Execution

@deftypefn Proc ISC_STATUS isc_dsql_execute status: ref ISC_STATUS_ARRAY; transaction: ref isc_tr_handle; statement: var isc_stmt_handle; dialect: cushort = SQL_DIALECT_CURRENT; [inx, ]outx: ptr XSQLDA = nil)
Runs a previously prepared statement.  @xref{isc_dsql_prepare}@.

@var{inx} may be left out, or @code{nil}, if a statement has no placeholders.  Statements with placeholders must be given a valid @code{XSQLDA} in the @var{inx} parameter.  @var{inx} contains the input values to replace each placeholder with.

@cite{http://docwiki.embarcadero.com/InterBase/XE7/en/Isc_dsql_execute()}@sp 0
@cite{http://docwiki.embarcadero.com/InterBase/XE7/en/Isc_dsql_execute2()}
@end deftypefn

@subsection Extraction

@deftypefn Proc ISC_STATUS isc_dsql_fetch status: ref ISC_STATUS_ARRAY; statement: var isc_stmt_handle; dialect: cushort = SQL_DIALECT_CURRENT; outx: ptr XSQLDA
Retrieves the next row of results from an executed query.  Values are read in to @var{outx}.

@cite{http://docwiki.embarcadero.com/InterBase/XE7/en/Isc_dsql_fetch()}
@end deftypefn

@section SQL Codes

@deftypefn Proc ISC_LONG isc_sqlcode const status: ref ISC_STATUS_ARRAY
Returns the SQL Code from the @var{status} error vector.  SQL Codes are set from actions such as executing statements.  Codes represent special situations such as failing to insert new rows due to constraint violations.
@end deftypefn

@node User Management
@chapter User Management

@deftypefn Proc ISC_STATUS isc_add_user @var{status}: var ISC_STATUS_ARRAY; data: var USER_SEC_DATA
@end deftypefn

@deftypefn Proc ISC_STATUS isc_delete_user @var{status}: var ISC_STATUS_ARRAY; data: var USER_SEC_DATA
@end deftypefn

@deftypefn Proc ISC_STATUS isc_modify_user @var{status}: var ISC_STATUS_ARRAY; data: var USER_SEC_DATA
@end deftypefn

@node XSQLDA
@chapter XSQLDA

@deftypefn Template int XSQLDA_LENGTH n: int
Returns the amount of memory which must be allocated to store an @code{XSQLDA} object with @var{n} variables.
@end deftypefn

@anchor{make_xsqlda}
@deftypefn Proc PXSQLDA make_xsqlda vars: int
Allocates a new @code{XSQLDA} in unmanaged memory, with enough slots for @var{vars} variables.  Must be freed manually, @xref{free_xsqlda}@.
@end deftypefn

@anchor{free_xsqlda}
@deftypefn Proc void free_xsqlda self: PXSQLDA; free_children: bool = true
Frees an @code{XSQLDA} that was previously allocated.  @xref{make_xsqlda}@.

If @var{free_children} is @code{true}, pointers within the variable that are non-@code{nil} will be freed with Nim's built-in @code{dealloc} routine.  If you are using pointers to local data buffers, or cheeky pointer manipulations with @code{alloc} memory, set this to @code{false}.
@end deftypefn

@deftypefn Proc PXSQLVAR [] self: PXSQLDA; index: int
Accesses the @var{index}'th variable within the @code{XSQLDA} object.  Assertions perform range checking in debug builds.  As a pointer is returned, changes to the result equal changes in the original @code{XSQLDA} object.  It goes without saying that values returned by this indexer do not live past the @code{XSQLDA} that they were taken from.
@end deftypefn

@section XSQL Variable Type

@anchor{XSQLVAR}
@example
XSQLVAR* @{.importc, header: ibase_h.@} = object
  sqltype*: ISC_SHORT
  sqlscale*: ISC_SHORT
  sqlsubtype*: ISC_SHORT
  sqllen*: ISC_SHORT
  sqldata*: pointer
  sqlind*: ptr ISC_SHORT
  sqlname_length*: ISC_SHORT
  sqlname*: array[0..31, ISC_SCHAR]
  relname_length*: ISC_SHORT
  relname*: array[0..31, ISC_SCHAR]
  ownname_length*: ISC_SHORT
  ownname*: array[0..31, ISC_SCHAR]
  aliasname_length*: ISC_SHORT
  aliasname*: array[0..31, ISC_SCHAR]
@end example

An @code{XSQLVAR} can represent either a variable going in to the database via a prepared statement (@xref{Prepared Queries}), or coming out of the database via a query.

@vtable @code
@item sqltype
The expected SQL type (when describing inputs to a prepared statement), the SQL type actually provided (when providing parameters to a prepared statement), or the data type returned by a query (when receiving data from the database.)

When assigning a data type to this field, add one to the type.  For example @code{SQL_TEXT + 1}.

@xref{SQL Data Types}@.

@anchor{sqlsubtype}
@item sqlsubtype
Subtypes provide more information about a kind of thing.  For example, some blobs represent different types of information.  The subtype field tells you what kind of information is stored in the bob.

In the case of @code{SQL_BLOB}, see @ref{blob subtypes}@.

@item sqllen
The number of bytes available in @var{sqldata} to read or write to.  Adjust this to either the @code{sizeof} a type (when using numeric types) or the available space in a text buffer when dealing with strings.

@item sqldata
A pointer to memory which contains the value either going in to, or coming out of the database.  May either be a reference to local variables@footnote{Be warned that since XSQLDAs are in memory not controlled by the garbage collector, there is no way for Nim to know an object is still in use by Firebird.  You should expect pointers to local values are valid only for Firebird calls within the proc which made the assignments.} or memory created with Nim's @code{alloc} routine.

@item sqlind
A pointer to a @code{cshort}.  Dereferenced, its value is interpreted as follows:

@table @samp
@item 0
A value is not @code{NULL} in SQL terms.

@item -1
A value is @code{NULL} in SQL terms.

@end table

@end vtable

@cite{http://docwiki.embarcadero.com/InterBase/XE7/en/XSQLVAR_Field_Descriptions}

@node Blobs
@chapter Blobs

@section Functions

@subsection Lifecycle

You need to @dfn{create} a blob if creating a new one, or @dfn{open} an existing blob to read from it.

@deftypefn Proc ISC_STATUS isc_create_blob status: var ISC_STATUS_ARRAY; db: var isc_db_handle; transaction: var isc_tr_handle; blob: var isc_blob_handle; blob_id: var ISC_QUAD[; bpb_len: cshort; bpb: cstring]
Creates a new blob in the database handled by @var{db}, in a @var{transaction}, storing a handle to the newly created blob in @var{blob} and returning the blob's ID in @var{blob_id}.  You need the @var{blob} handle to write to it (@pxref{isc_put_segment}) and the @var{blob_id} to pass this blob to records via an @code{XSQLVAR}.

It is also possible to provide a @emph{blob parameter buffer}.  Supply the length of the buffer in @var{bpb_len} and the buffer itself in @var{bpb}.  If these two values are not provided, it is assumed there are no special parameters.
@end deftypefn

@deftypefn Proc ISC_STATUS isc_open_blob status: var ISC_STATUS_ARRAY; db: var isc_db_handle; transaction: var isc_tr_handle; blob: var isc_blob_handle; blob_id: var ISC_QUAD

@table @var
@item status
A reference to a status error vector.

@item isc_db_handle
A handle to the database containing the blob you are opening.

@item isc_tr_handle

@item blob
A handle which will represent the opened blob.  It will be assigned to on a successful call to @code{isc_open_blob}.

@item blob_id
Identifies a blob to open from the database.

@end table

@end deftypefn

When you are done with a blob, whether created or opened, you will need to @dfn{close} it.

@deftypefn Proc ISC_STATUS isc_close_blob status: var ISC_STATUS_ARRAY; blob: var isc_blob_handle

@table @var
@item status
A reference to a status error vector.

@item blob
A handle to a blob previously opened by @code{isc_open_blob}.

@end table

@end deftypefn

@cite{Firebird 3.0's example/api/api@{7,8@}.c files}

@subsection Retrieval

@deftypefn Proc ISC_STATUS isc_get_segment status: var ISC_STATUS_ARRAY; blob: var isc_blob_handle; read_len: var cushort; blen: cushort; buf: ptr int8
Reads the next @var{blen} bytes of data from a @var{blob}, storing the results in @var{buf} and returning the actual number of bytes read to @var{read_len}.
@end deftypefn

@cite{Firebird 3.0's example/api/api7.c files}@sp 0
@cite{http://docwiki.embarcadero.com/InterBase/XE7/en/Isc_get_segment()}

@subsection Storage

@anchor{isc_put_segment}
@deftypefn Proc ISC_STATUS isc_put_segment status: var ISC_STATUS_ARRAY; blob: var isc_blob_handle; blen: cushort; buf: ptr int8
Writes @var{blen} bytes of data from @var{buf} to a given @var{blob}.
@end deftypefn

@section Subtypes

A blob's sub-type is stored in the @code{sqlsubtype} parameter of an @code{XSQLVAR}, and determines what kind of data is stored and what SQL commands are available.  @xref{sqlsubtype}@.

@anchor{blob subtypes}
@table @samp
@item 0
Binary data.

@item 1
Text.

@item 2
BLR (internal Firebird stuff).

@end table

@cite{http://www.firebirdfaq.org/faq165/}

@node SQL Data Types
@chapter SQL Data Types

As Firebird's documentation is lacking on which specific types match up to which SQL types, a convenient mapping of SQL types to Nim is provided:

@multitable {SQL_TIMESTAMP} {Memory buffer}
@headitem Type name
@tab Nim type
@item SQL_TEXT
@tab Memory buffer
@item SQL_VARYING
@tab Memory buffer
@item SQL_SHORT
@tab cshort
@item SQL_LONG
@tab clong
@item SQL_FLOAT
@tab cfloat
@item SQL_DOUBLE
@tab cdouble
@item SQL_D_FLOAT
@tab ???
@item SQL_TIMESTAMP
@tab ISC_TIMESTAMP
@item SQL_BLOB
@tab GDS_QUAD
@item SQL_ARRAY
@tab GDS_QUAD
@item SQL_QUAD
@tab GDS_QUAD
@item SQL_TYPE_TIME
@tab ISC_TIME
@item SQL_TYPE_DATE
@tab ISC_DATE
@item SQL_INT64
@tab int64
@item SQL_BOOLEAN
@tab ???
@item SQL_NULL
@tab ???
@end multitable

@var{SQL_DATE} is synonymous with @var{SQL_TIMESTAMP}.

@code{SQL_BLOB} has multiple sub-types, see @ref{blob subtypes}@.

@quotation Memory buffer
These types take a raw pointer to memory, where text is stored.  The @var{sqllen} field of an @code{XSQLVAR} is used to determine how long the buffer must be (when receiving data) or actually is (when sending data.)  @xref{XSQLVAR}@.
@end quotation

@cite{Firebird 3.0's example/api/*.c files}

@node Cursors
@chapter Cursors

@deftypefn Proc ISC_STATUS isc_dsql_set_cursor_name status: var ISC_STATUS_ARRAY; statement: var isc_stmt_handle; name: cstring; unused: cushort = 0
Sets the cursor @var{name} for a given @var{statement}.

@cite{http://docwiki.embarcadero.com/InterBase/XE7/en/Isc_dsql_set_cursor_name()}
@end deftypefn

@node Arrays
@chapter Arrays

@deftypefn Proc ISC_STATUS isc_array_lookup_bounds status: var ISC_STATUS_ARRAY; db: var isc_db_handle; transaction: var isc_tr_handle; table_name, column_name: cstring; desc: var ISC_ARRAY_DESC

@cite{Firebird 3.0's example/api/api10.c files}@sp 0
@cite{http://docwiki.embarcadero.com/InterBase/XE7/en/Isc_array_lookup_bounds2()}
@end deftypefn

@deftypefn Proc ISC_STATUS isc_array_get_slice status: var ISC_STATUS_ARRAY; db: var isc_db_handle; transaction: var isc_tr_handle; array_id: var ISC_QUAD; desc: var ISC_ARRAY_DESC; buf: pointer; buflen: var ISC_LONG
Writes @var{buflen} bytes from the buffer @var{buf} to the array with handle @var{array_id} and described by @var{desc}.  The number of bytes actually written is written back to @var{buflen}.

@cite{Firebird 3.0's example/api/api10.c files}@sp 0
@cite{http://docwiki.embarcadero.com/InterBase/XE7/en/Isc_array_get_slice2()}
@end deftypefn

@deftypefn Proc ISC_STATUS isc_array_put_slice status: var ISC_STATUS_ARRAY; db: var isc_db_handle; transaction: var isc_tr_handle; array_id: var ISC_QUAD; desc: var ISC_ARRAY_DESC; buf: pointer; buflen: var ISC_LONG
Reads @var{buflen} bytes in to buffer @var{buf} from the array with a handle @var{array_id} and a description @var{desc}.  The number of bytes actually read is written back to @var{buflen}.

@cite{Firebird 3.0's example/api/api10.c files}@sp 0
@cite{http://docwiki.embarcadero.com/InterBase/XE7/en/Isc_array_put_slice2()}
@end deftypefn

@node Silliness with Numbers
@chapter Silliness with Numbers

@deftypefn Proc ISC_LONG isc_vax_integer buf: pointer; size: cshort
@deftypefnx Proc ISC_INT64 isc_portable_integer buf: pointer; size: cshort

Flips the byte order of numbers, converting them from little-endian to big-endian and vice versa.  @var{buf} is a pointer to the number being converted, while @var{size} is the number of bytes for the integer type.  @code{isc_vax_integer} supports lengths of 1, 2 and 4 bytes.  @code{isc_portable_integer} supports lengths of 1, 2, 4 and 8 bytes.

@cite{http://docwiki.embarcadero.com/InterBase/XE7/en/Isc_vax_integer()} @sp 0
@cite{http://docwiki.embarcadero.com/InterBase/XE7/en/Isc_portable_integer()}
@end deftypefn

@node Index of Procs
@appendix Index of Procs

@syncodeindex vr fn
@printindex fn

@bye
