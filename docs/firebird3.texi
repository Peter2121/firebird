
@settitle Nimized Firebird 3

@ifnottex
@node Top
@top

@end ifnottex

@node Database connections
@chapter Database connections

@quotation Note
It is possible to use Pascal-style string handling, where a pointer to text and a given length of the text is passed to this function. Presently that method has been wrapped over, enforcing the use of cstrings. A ``proper'' version which accepts native Nim strings might be possible.
@end quotation

@deftypefn Function ISC_STATUS isc_attach_database @var{status_vector}: ref ISC_STATUS_ARRAY; @var{db_name}: cstring; @var{db}: ref isc_db_handle; @var{parm_buffer_length}: cshort = 0; @var{parm_buffer}: cstring = nil

Attaches a new database.

@table @code
@item status
Error status vector.

@item db_name
Name of the database to attach.

@item db
Handle; will be overriden to either @code{NULL} on error, or the handle to the attached database on success.

@item parm_buffer_length
Length of the database parameter buffer.

@item parm_buffer
A specially constructed string, which acts as a set of parameters for the database. Connection information such as the username and password to connect with are specified here.
@end table

@cite{http://docwiki.embarcadero.com/InterBase/XE7/en/Isc_attach_database()}

@end deftypefn

@deftypefn Function ISC_STATUS isc_detach_database @var{status}: ref ISC_STATUS, @var{db}: ref isc_db_handle)

Releases a previously attached database.

@table @code
@item status
Error status vector.

@item db
Handle to the database to be freed.

@end table

@cite{http://docwiki.embarcadero.com/InterBase/XE7/en/Isc_detach_database()}

@end deftypefn

@node Transactions
@chapter Transactions

@deftypefn Function ISC_STATUS isc_start_transaction status: ref ISC_STATUS_ARRAY; transaction: ref isc_tr_handle; db: var isc_db_handle; tpb_length: cushort; tpb: cstring

Starts a new transaction, storing a handle to the transaction within @var{transaction}. The database in question is specified with the handle @var{db}. If a transaction parameter buffer is used, its length and string are supplied. The nimized version of this function defaults both transaction parameter buffer options to nil.

@quotation Note
Firebird supports transactions against multiple open databases; the API for doing this in a Nim-supported way is a little hairy, so it was (for now) simplified to a call that works on a single database.
@end quotation

@cite{http://docwiki.embarcadero.com/InterBase/XE7/en/Isc_start_transaction()}
@end deftypefn

@deftypefn Function ISC_STATUS isc_rollback_transaction status: ref ISC_STATUS_ARRAY, transaction: ref isc_tr_handle

Aborts a transaction; any changes that would have been made inside of it are not made. The database remains unchanged.
@end deftypefn

@anchor{isc_commit_transaction}
@deftypefn Function ISC_STATUS isc_commit_transaction status: var ISC_STATUS_ARRAY; tr: var isc_tr_handle

Commits a transaction; any changes that would have been made inside of it are now made if possible.  Should an error occur while trying to commit any data, @emph{none} of the changes will be made.
@end deftypefn

@node Running queries
@chapter Running queries

@anchor{Immediate Queries}
@section Immediate Queries

An immediate query is one where its @dfn{statement} is prepared, executed, and deleted, in one call. A query which is run very infrequently or prepares a database might be run immediately. For queries that are going to be run many times within an application's lifecycle, refer to @ref{Prepared Queries}.  Immediate queries also do not allow values to be @dfn{bound} to placeholders and so are unsuitable for any query which accepts information from untrusted sources.

@quotation Note
An immediate query only means a statement is not prepared in advance. It does @emph{not} mean the statement bypasses any pending transactions.
@end quotation

@deftypefn Function ISC_STATUS isc_dsql_execute_immediate status: var ISC_STATUS_ARRAY; db: var isc_db_handle; transaction: var isc_tr_handle; query: cstring; dialect: cushort = SQL_DIALECT_CURRENT; xsql: var XSQLDA = nil

Runs a statement that does not return data.

If running a @code{CREATE DATABASE} query, @var{db} and @var{transaction} should initially be zero. A handle to the new database is written to @var{db}, and a new transaction is started whom's handle is written to @var{transaction}. You must commit the transaction to finish creating the database. @xref{isc_commit_transaction}

@cite{http://docwiki.embarcadero.com/InterBase/XE7/en/Isc_dsql_execute_immediate()}
@end deftypefn

@deftypefn Function ISC_STATUS isc_dsql_exec_immed2 status: var ISC_STATUS_ARRAY; db: var isc_db_handle; transaction: var isc_tr_handle; statement_length: cushort; statement: cstring; dialect: cushort = SQL_DIALECT_CURRENT; inx, outx: ptr XSQLDA = nil

Runs a statement which returns no more than a single row of results.

@cite{http://docwiki.embarcadero.com/InterBase/XE7/en/Isc_dsql_exec_immed2()}
@end deftypefn

@anchor{Prepared Queries}
@section Prepared Queries

@subsection Lifecycle

@deftypefn Function ISC_STATUS isc_dsql_allocate_statement status: ref ISC_STATUS_ARRAY; db: ref isc_db_handle; statement: var isc_stmt_handle; autofree: bool = true

Allocates a handle for a prepared statement. @var{autofree} statements are cleaned up when their database is detached, otherwise you must clean up the handle manually.

@cite{http://docwiki.embarcadero.com/InterBase/XE7/en/Isc_dsql_allocate_statement()}@sp 0
@cite{http://docwiki.embarcadero.com/InterBase/XE7/en/Isc_dsql_alloc_statement2()}
@end deftypefn

@deftypefn Function ISC_STATUS isc_dsql_free_statement status: ref ISC_STATUS_ARRAY; statement: var isc_stmt_handle; on_free: StatementFreeType

Explicitly frees a previously allocated statement.  Not necessary for statements created with @var{autofree = true}.

@table @code
@item status
Error status vector.

@item statement
A handle to the statement you want freed.

@item on_free
Action to handle when freeing the statement.  May be one of the following:

@table @code
@item DSQL_close
Closes any open cursors using this statement.  The handle and statement remain valid and prepared for future use.

@item DSQL_unprepare
Closes any open cursors using this statement, and removes the statement from the handle.  The handle remains valid and may have another statement prepared with it.

@item DSQL_drop
Like unprepare, but the handle is destroyed after the statement is unprepared.

@end table

@end table

@cite{https://stackoverflow.com/questions/35924822/firebird-c-client-api-statement-transaction-and-cursor-lifecycle#35956754}

@end deftypefn

@subsection Preparation

@anchor{isc_dsql_prepare}
@deftypefn Function ISC_STATUS isc_dsql_prepare status: var ISC_STATUS_ARRAY; transaction: var isc_tr_handle; statement_handle: var isc_stmt_handle; statement: cstring; dialect: cushort = SQL_DIALECT_CURRENT; xsql: ptr XSQLDA = nil
@end deftypefn

@subsection Execution

@deftypefn Function ISC_STATUS isc_dsql_execute status: ref ISC_STATUS_ARRAY; transaction: ref isc_tr_handle; statement: var isc_stmt_handle; dialect: cushort = SQL_DIALECT_CURRENT; [inx, ]outx: ptr XSQLDA = nil)
Runs a previously prepared statement.  @xref{isc_dsql_prepare}@.

@var{inx} may be left out, or @code{nil}, if a statement has no placeholders.  Statements with placeholders must be given a valid @code{XSQLDA} in the @var{inx} parameter.  @var{inx} contains the input values to replace each placeholder with.

@cite{http://docwiki.embarcadero.com/InterBase/XE7/en/Isc_dsql_execute()}@sp 0
@cite{http://docwiki.embarcadero.com/InterBase/XE7/en/Isc_dsql_execute2()}
@end deftypefn

@node User Management
@chapter User Management

@deftypefn Function ISC_STATUS isc_add_user @var{status}: var ISC_STATUS_ARRAY; data: var USER_SEC_DATA
@end deftypefn

@deftypefn Function ISC_STATUS isc_delete_user @var{status}: var ISC_STATUS_ARRAY; data: var USER_SEC_DATA
@end deftypefn

@deftypefn Function ISC_STATUS isc_modify_user @var{status}: var ISC_STATUS_ARRAY; data: var USER_SEC_DATA
@end deftypefn

@node Index of Functions
@appendix Index of Functions

@printindex fn

@bye
