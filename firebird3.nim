# Initial Developer's Public License Version 1.0 1. Definitions

# 1.0 "Commercial Use" means distribution or otherwise making the
# Covered Code available to a third party.

# 1.1 "Contributor" means each entity that creates or contributes to
# the creation of Modifications.

# 1.2 "Contributor Version" means the combination of the Original
# Code, prior Modifications used by a Contributor, and the
# Modifications made by that particular Contributor.

# 1.3. "Covered Code" means the Original Code or Modifications or the
# combination of the Original Code and Modifications, in each case
# including portions thereof.

# 1.4. "Electronic Distribution Mechanism" means a mechanism generally
# accepted in the software development community for the electronic
# transfer of data.

# 1.5. "Executable" means Covered Code in any form other than Source
# Code.

# 1.6. "Initial Developer" means the individual or entity identified
# as the Initial Developer in the Source Code notice required by
# Exhibit A.

# 1.7. "Larger Work" means a work which combines Covered Code or
# portions thereof with code not governed by the terms of this
# License.

# 1.8. "License" means this document.

# 1.8.1. "Licensable" means having the right to grant, to the maximum
# extent possible, whether at the time of the initial grant or
# subsequently acquired, any and all of the rights conveyed herein.

# 1.9. "Modifications" means any addition to or deletion from the
# substance or structure of either the Original Code or any previous
# Modifications. When Covered Code is released as a series of files, a
# Modification is:

# Any addition to or deletion from the contents of a file containing
# Original Code or previous Modifications.

# Any new file that contains any part of the Original Code or previous
# Modifications.

# 1.10. "Original Code" means Source Code of computer software code
# which is described in the Source Code notice required by Exhibit A
# as Original Code, and which, at the time of its release under this
# License is not already Covered Code governed by this License.

# 1.10.1. "Patent Claims" means any patent claim(s), now owned or
# hereafter acquired, including without limitation, method, process,
# and apparatus claims, in any patent Licensable by grantor.

# 1.11. "Source Code" means the preferred form of the Covered Code for
# making modifications to it, including all modules it contains, plus
# any associated interface definition files, scripts used to control
# compilation and installation of an Executable, or source code
# differential comparisons against either the Original Code or another
# well known, available Covered Code of the Contributor's choice. The
# Source Code can be in a compressed or archival form, provided the
# appropriate decompression or de-archiving software is widely
# available for no charge.

# 1.12. "You" (or "Your") means an individual or a legal entity
# exercising rights under, and complying with all of the terms of,
# this License or a future version of this License issued under
# Section 6.1. For legal entities, "You" includes any entity w hich
# controls, is controlled by, or is under common control with You. For
# purposes of this definition, "control" means (a) the power, direct
# or indirect, to cause the direction or management of such entity,
# whether by contract or otherwise, or (b) ownership of more than
# fifty percent (50%) of the outstanding shares or beneficial
# ownership of such entity.

# 2. Source Code License.

# 2.1. The Initial Developer Grant. The Initial Developer hereby
# grants You a world-wide, royalty-free, non-exclusive license,
# subject to third party intellectual property claims:

# (a) under intellectual property rights (other than patent or
# trademark) Licensable by Initial Developer to use, reproduce,
# modify, display, perform, sublicense and distribute the Original
# Code (or portions thereof) with or without Modifications, and/or as
# part of a Larger Work; and

# (b) under Patents Claims infringed by the making, using or selling
# of Original Code, to make, have made, use, practice, sell, and offer
# for sale, and/or otherwise dispose of the Original Code (or portions
# thereof).

# (c) the licenses granted in this Section 2.1(a) and (b) are
# effective on the date Initial Developer first distributes Original
# Code under the terms of this License.

# d) Notwithstanding Section 2.1(b) above, no patent license is
# granted:

# 1) for code that You delete from the Original Code;

# 2) separate from the Original Code; or

# 3) for infringements caused by:

# i) the modification of the Original Code or

# ii) the combination of the Original Code with other software or
# devices.

# 2.2. Contributor Grant. Subject to third party intellectual property
# claims, each Contributor hereby grants You a world-wide,
# royalty-free, non-exclusive license

# (a) under intellectual property rights (other than patent or
# trademark) Licensable by Contributor, to use, reproduce, modify,
# display, perform, sublicense and distribute the Modifications
# created by such Contributor (or portions thereof) either on an
# unmodified basis, with other Modifications, as Covered Code and/or
# as part of a Larger Work; and

# (b) under Patent Claims infringed by the making, using, or selling
# of Modifications made by that Contributor either alone and/or in
# combination with its Contributor Version (or portions of such
# combination), to make, use, sell, offer for sale, have made, and/or
# otherwise dispose of: 1) Modifications made by that Contributor (or
# portions thereof); and 2) the combination of Modifications made by
# that Contributor with its Contributor Version (or portions of such
# combination).

# (c) the licenses granted in Sections 2.2(a) and 2.2(b) are effective
# on the date Contributor first makes Commercial Use of the Covered
# Code.

# (d) Notwithstanding Section 2.2(b) above, no patent license is
# granted:

# 1) for any code that Contributor has deleted from the Contributor
# Version;

# 2) separate from the Contributor Version;

# 3) for infringements caused by: i) third party modifications of
# Contributor Version or

# ii) the combination of Modifications made by that Contributor with
# other software (except as part of the Contributor Version) or other
# devices; or

# 4) under Patent Claims infringed by Covered Code in the absence of
# Modifications made by that Contributor.

# 3. Distribution Obligations.

# 3.1. Application of License. The Modifications which You create or
# to which You contribute are governed by the terms of this License,
# including without limitation Section 2.2. The Source Code version of
# Covered Code may be distributed only under the terms of this License
# or a future version of this License released under Section 6.1, and
# You must include a copy of this License with every copy of the
# Source Code You distribute. You may not offer or impose any terms on
# any Source Code version that alters or restricts the applicable
# version of this License or the recipients' rights
# hereunder. However, You may include an additional document offering
# the additional rights described in Section 3.5.

# 3.2. Availability of Source Code. Any Modification which You create
# or to which You contribute must be made available in Source Code
# form under the terms of this License either on the same media as an
# Executable version or via an accepted Electronic Distribution
# Mechanism to anyone to whom you made an Executable version
# available; and if made available via Electronic Distribution
# Mechanism, must remain available for at least twelve (12) months
# after the date it initially became available, or at least six (6)
# months after a subsequent version of that particular Modification
# has been made available to such recipients. You are responsible for
# ensuring that the Source Code version remains available even if the
# Electronic Distribution Mechanism is maintained by a third party.

# 3.3. Description of Modifications. You must cause all Covered Code
# to which You contribute to contain a file documenting the changes
# You made to create that Covered Code and the date of any change. You
# must include a prominent statement that the Modification is derived,
# directly or indirectly, from Original Code provided by the Initial
# Developer and including the name of the Initial Developer in

# (a) the Source Code, and

# (b) in any notice in an Executable version or related documentation
# in which You describe the origin or ownership of the Covered Code.

# 3.4. Intellectual Property Matters

# a) Third Party Claims. If Contributor has knowledge that a license
# under a third party's intellectual property rights is required to
# exercise the rights granted by such Contributor under Sections 2.1
# or 2.2, Contributor must include a text file with the Source Code
# distribution titled "LEGAL" which describes the claim and the party
# making the claim in sufficient detail that a recipient will know
# whom to contact. If Contributor obtains such knowledge after the
# Modification is made available as described in Section 3.2,
# Contributor shall promptly modify the LEGAL file in all copies
# Contributor makes available thereafter and shall take other steps
# (such as notifying appropriate mailing lists or newsgroups)
# reasonably calculated to inform those who received the Covered Code
# that new knowledge has been obtained.

# (b) Contributor APIs. If Contributor's Modifications include an
# application programming interface and Contributor has knowledge of
# patent licenses which are reasonably necessary to implement that
# API, Contributor must also include this information in the LEGAL
# file.

# (c) Representations. Contributor represents that, except as
# disclosed pursuant to Section 3.4(a) above, Contributor believes
# that Contributor's Modifications are Contributor's original
# creation(s) and/or Contributor has sufficient rights to grant the
# rights conveyed by this License.

# 3.5. Required Notices. You must duplicate the notice in Exhibit A in
# each file of the Source Code. If it is not possible to put such
# notice in a particular Source Code file due to its structure, then
# You must include such notice in a location (such as a relevant
# directory) where a user would be likely to look for such a
# notice. If You created one or more Modification(s) You may add your
# name as a Contributor to the notice described in Exhibit A. You must
# also duplicate this License in any documentation for the Source Code
# where You describe recipients' rights or ownership rights relating
# to Covered Code. You may choose to offer, and to charge a fee for,
# warranty, support, indemnity or liability obligations to one or more
# recipients of Covered Code. However, You may do so only on Your own
# behalf, and not on behalf of the Initial Developer or any
# Contributor. You must make it absolutely clear than any such
# warranty, support, indemnity or liability obligation is offered by
# You alone, and You hereby agree to indemnify the Initial Developer
# and every Contributor for any liability incurred by the Initial
# Developer or such Contributor as a result of warranty, support,
# indemnity or liability terms You offer.

# 3.6. Distribution of Executable Versions. You may distribute Covered
# Code in Executable form only if the requirements of Section 3.1-3.5
# have been met for that Covered Code, and if You include a notice
# stating that the Source Code version of the Covered Code is
# available under the terms of this License, including a description
# of how and where You have fulfilled the obligations of Section
# 3.2. The notice must be conspicuously included in any notice in an
# Executable version, related documentation or collateral in which You
# describe recipients' rights relating to the Covered Code. You may
# distribute the Executable version of Covered Code or ownership
# rights under a license of Your choice, which may contain terms
# different from this License, provided that You are in compliance
# with the terms of this License and hat the license for the
# Executable version does not attempt to limit or alter the
# recipient's rights in the Source Code version from the rights set
# forth in this License. If You distribute the Executable version
# under a different license You must make it absolutely clear that any
# terms which differ from this License are offered by You alone, not
# by the Initial Developer or any Contributor. You hereby agree to
# indemnify the Initial Developer and every Contributor for any
# liability incurred by the Initial Developer or such Contributor as a
# result of any such terms You offer.

# 3.7. Larger Works. You may create a Larger Work by combining Covered
# Code with other code not governed by the terms of this License and
# distribute the Larger Work as a single product. In such a case, You
# must make sure the requirements of this License are fulfilled for
# the Covered Code.

# 4. Inability to Comply Due to Statute or Regulation.

# If it is impossible for You to comply with any of the terms of this
# License with respect to some or all of the Covered Code due to
# statute, judicial order, or regulation then You must:

# (a) comply with the terms of this License to the maximum extent
# possible; and

# (b) describe the limitations and the code they affect. Such
# description must be included in the LEGAL file described in Section
# 3.4 and must be included with all distributions of the Source
# Code. Except to the extent prohibited by statute or regulation, such
# description must be sufficiently detailed for a recipient of
# ordinary skill to be able to understand it.

# 5. Application of this License.

# This License applies to code to which the Initial Developer has
# attached the notice in Exhibit A and to related Covered Code.

# 6. Versions of the License.

# 6.1. New Versions. The Initial Developer of this code may publish
# revised and/or new versions of the License from time to time. Each
# version will be given a distinguishing version number.

# 6.2. Effect of New Versions. Once Covered Code has been published
# under a particular version of the License, You may always continue
# to use it under the terms of that version. You may also choose to
# use such Covered Code under the terms of any subsequent version of
# the License published by the Initial Developer. No one other than
# the Initial Developer has the right to modify the terms applicable
# to Covered Code created under this License.

# 6.3. Derivative Works. If You create or use a modified version of
# this License (which you may only do in order to apply it to code
# which is not already Covered Code governed by this License), You
# must

# (a) rename Your license so that the phrases "Mozilla", "MOZILLAPL",
# "MOZPL", "Netscape", "MPL", "NPL", or any confusingly similar
# phrases do not appear in your license (except to note that your
# license differs from this License) and

# (b) otherwise make it clear that Your version of the license
# contains terms which differ from the Mozilla Public License and
# Netscape Public License. (Filling in the name of the Initial
# Developer, Original Code or Contributor in the notice described in
# Exhibit A shall not of themselves be deemed to be modifications of
# this License.)

# 6.4 Origin of the Initial Developer's Public License. The Initial
# Developer's Public License is based on the Mozilla Public License V
# 1.1 with the following changes:

# 1) The license is published by the Initial Developer of this
# code. Only the Initial Developer can modify the terms applicable to
# Covered Code.

# 2) The license can be modified and used for code which is not
# already governed by this license. Modified versions of the license
# must be renamed to avoid confusion with the Initial Developer's
# Public License and must include a description of changes from the
# Initial Developer's Public License.

# 3) The name of the license in Exhibit A is the "Initial Developer's
# Public License".

# 4) The reference to an alternative license in Exhibit A has been
# removed .

# 5) Amendments I, II, III, V, and VI have been deleted.

# 6) Exhibit A, Netscape Public License has been deleted

# 7. DISCLAIMER OF WARRANTY.

# COVERED CODE IS PROVIDED UNDER THIS LICENSE ON AN "AS IS" BASIS,
# WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED,
# INCLUDING, WITHOUT LIMITATION, WARRANTIES THAT THE COVERED CODE IS
# FREE OF DEFECTS, MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE OR
# NON-INFRINGING. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF
# THE COVERED CODE IS WITH YOU. SHOULD ANY COVERED CODE PROVE
# DEFECTIVE IN ANY RESPECT, YOU (NOT THE INITIAL DEVELOPER OR ANY
# OTHER CONTRIBUTOR) ASSUME THE COST OF ANY NECESSARY SERVICING,
# REPAIR OR CORRECTION. THIS DISCLAIMER OF WARRANTY CONSTITUTES AN
# ESSENTIAL PART OF THIS LICENSE. NO USE OF ANY COVERED CODE IS
# AUTHORIZED HEREUNDER EXCEPT UNDER THIS DISCLAIMER.

# 8. TERMINATION.

# 8.1. This License and the rights granted hereunder will terminate
# automatically if You fail to comply with terms herein and fail to
# cure such breach within 30 days of becoming aware of the breach. All
# sublicenses to the Covered Code which are properly granted shall
# survive any termination of this License. Provisions which, by their
# nature, must remain in effect beyond the termination of this License
# shall survive.

# 8.2. If You initiate litigation by asserting a patent infringement
# claim (excluding declatory judgment actions) against Initial
# Developer or a Contributor (the Initial Developer or Contributor
# against whom You file such action is referred to as "Participant")
# alleging that:

# (a) such Participant's Contributor Version directly or indirectly
# infringes any patent, then any and all rights granted by such
# Participant to You under Sections 2.1 and/or 2.2 of this License
# shall, upon 60 days notice from Participant terminate prospectively,
# unless if within 60 days after receipt of notice You either:

# (i) agree in writing to pay Participant a mutually agreeable
# reasonable royalty for Your past and future use of Modifications
# made by such Participant, or

# (ii) withdraw Your litigation claim with respect to the Contributor
# Version against such Participant.

# If within 60 days of notice, a reasonable royalty and payment
# arrangement are not mutually agreed upon in writing by the parties
# or the litigation claim is not withdrawn, the rights granted by
# Participant to You under Sections 2.1 and/or 2.2 automatically
# terminate at the expiration of the 60 day notice period specified
# above.

# (b) any software, hardware, or device, other than such Participant's
# Contributor Version, directly or indirectly infringes any patent,
# then any rights granted to You by such Participant under Sections
# 2.1(b) and 2.2(b) are revoked effective as of the date You first
# made, used, sold, distributed, or had made, Modifications made by
# that Participant.

# 8.3. If You assert a patent infringement claim against Participant
# alleging that such Participant's Contributor Version directly or
# indirectly infringes any patent where such claim is resolved (such
# as by license or settlement) prior to the initiation of patent
# infringement litigation, then the reasonable value of the licenses
# granted by such Participant under Sections 2.1 or 2.2 shall be taken
# into account in determining the amount or value of any payment or
# license.

# 8.4. In the event of termination under Sections 8.1 or 8.2 above,
# all end user license agreements (excluding distributors and
# resellers) which have been validly granted by You or any distributor
# hereunder prior to termination shall survive termination.

# 9. LIMITATION OF LIABILITY.

# UNDER NO CIRCUMSTANCES AND UNDER NO LEGAL THEORY, WHETHER TORT
# (INCLUDING NEGLIGENCE), CONTRACT, OR OTHERWISE, SHALL YOU, THE
# INITIAL DEVELOPER, ANY OTHER CONTRIBUTOR, OR ANY DISTRIBUTOR OF
# COVERED CODE, OR ANY SUPPLIER OF ANY OF SUCH PARTIES, BE LIABLE TO
# ANY PERSON FOR ANY INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
# DAMAGES OF ANY CHARACTER INCLUDING, WITHOUT LIMITATION, DAMAGES FOR
# LOSS OF GOODWILL, WORK STOPPAGE, COMPUTER FAILURE OR MALFUNCTION, OR
# ANY AND ALL OTHER COMMERCIAL DAMAGES OR LOSSES, EVEN IF SUCH PARTY
# SHALL HAVE BEEN INFORMED OF THE POSSIBILITY OF SUCH DAMAGES. THIS
# LIMITATION OF LIABILITY SHALL NOT APPLY TO LIABILITY FOR DEATH OR
# PERSONAL INJURY RESULTING FROM SUCH PARTY'S NEGLIGENCE TO THE EXTENT
# APPLICABLE LAW PROHIBITS SUCH LIMITATION. SOME JURISDICTIONS DO NOT
# ALLOW THE EXCLUSION OR LIMITATION OF INCIDENTAL OR CONSEQUENTIAL
# DAMAGES, SO THIS EXCLUSION AND LIMITATION MAY NOT APPLY TO YOU.

# 10. U.S. GOVERNMENT END USERS.

# The Covered Code is a "commercial item", as that term is defined in
# 48 C.F.R. 2.101 (Oct. 1995), consisting of "commercial computer
# software" and "commercial computer software documentation", as such
# terms are used in 48 C.F.R. 12.212 (Sept. 1995). Consistent with 48
# C.F.R. 12.212 and 48 C.F.R. 227.7202-1 through 227.7202-4 (June
# 1995), all U.S. Government End Users acquire Covered Code with only
# those rights set forth herein.

# 11. MISCELLANEOUS.

# This License represents the complete agreement concerning subject
# matter hereof. If any provision of this License is held to be
# unenforceable, such provision shall be reformed only to the extent
# necessary to make it enforceable. This License shall be governed by
# California law provisions (except to the extent applicable law, if
# any, provides otherwise), excluding its conflict-of-law
# provisions. With respect to disputes in which at least one party is
# a citizen of, or an entity chartered or registered to do business in
# the United States of America, any litigation relating to this
# License shall be subject to the jurisdiction of the Federal Courts
# of the Northern District of California, with venue lying in Santa
# Clara County, California, with the losing party responsible for
# costs, including without limitation, court costs and reasonable
# attorneys' fees and expenses. The application of the United Nations
# Convention on Contracts for the International Sale of Goods is
# expressly excluded. Any law or regulation which provides that the
# language of a contract shall be construed against the drafter shall
# not apply to this License.

# 12. RESPONSIBILITY FOR CLAIMS.

# As between Initial Developer and the Contributors, each party is
# responsible for claims and damages arising, directly or indirectly,
# out of its utilization of rights under this License and You agree to
# work with Initial Developer and Contributors to distribute such
# responsibility on an equitable basis. Nothing herein is intended or
# shall be deemed to constitute any admission of liability.

# 13. MULTIPLE-LICENSED CODE.

# Initial Developer may designate portions of the Covered Code as
# "Multiple-Licensed". "Multiple-Licensed" means that the Initial
# Developer permits you to utilize portions of the Covered Code under
# Your choice of the IDPL or the alternative licenses, if any,
# specified by the Initial Developer in the file described in Exhibit
# A.

# EXHIBIT A -Initial Developer's Public License.

# The contents of this file are subject to the Initial Developer's
# Public License Version 1.0 (the "License"); you may not use this
# file except in compliance with the License. You may obtain a copy of
# the License from the Firebird Project website, at
# http://www.firebirdsql.org/en/initial-developer-s-public-license-version-1-0/

# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
# the License for the specific language governing rights and
# limitations under the License.

{.passc: staticExec("fb_config --cflags").}
{.passl: "-lfbclient".}

assert int.sizeof == pointer.sizeof

const
  ibase_h = "ibase.h"

  FB_API_VER* {.importc, header: ibase_h.} = 30
  isc_version4* {.importc, header: ibase_h.} = 1
  ISC_FAR* {.importc, header: ibase_h.} = 1
  ISC_TRUE* {.importc, header: ibase_h.} = 1
  ISC_FALSE* {.importc, header: ibase_h.} = 0

#* API handles                                                    */
#******************************************************************/

# TODO is this right?
when defined(amd64):
  type
    FB_API_HANDLE* {.importc, header: ibase_h.} = cuint
else:
  type
    FB_API_HANDLE* {.importc, header: ibase_h.} = pointer

#* Sizes of memory blocks                                         */
#******************************************************************/

# TODO should probably tell the user about this?

when defined(fb_use_size_t):
  type
    FB_SIZE_T* {.importc, header: ibase_h.} = csize
    FB_SSIZE_T* {.importc, header: ibase_h.} = int
else:
  type
    FB_SIZE_T* {.importc, header: ibase_h.} = cuint
    FB_SSIZE_T* {.importc, header: ibase_h.} = cint

#* Status vector                                                  */
#******************************************************************/

const
  STATUS_LENGTH* {.importc: "ISC_STATUS_LENGTH", header: ibase_h.} = 20
  FB_SQLSTATE_LENGTH* {.importc, header: ibase_h.} = 5
  FB_SQLSTATE_SIZE* {.importc, header: ibase_h.} = (FB_SQLSTATE_LENGTH + 1)

type
  STATUS* {.importc: "ISC_STATUS", header: ibase_h.} = int # XXX Araq says nim int is always the same size as pointer
  STATUS_ARRAY* = array[0..(STATUS_LENGTH-1), STATUS]
  FB_SQLSTATE_STRING* = array[0..(FB_SQLSTATE_SIZE-1), cchar]

type
  FirebirdException* = object of Exception
    status*: STATUS_ARRAY

proc new_firebird_exception*(status: var STATUS_ARRAY): ref FirebirdException {.inline.} =
  # TODO interrogate error vector for a proper string
  result = newexception(FirebirdException, "Firebird error.")
  for x in low(result.status)..high(result.status):
    result.status[x] = status[x]

#* Define type, export and other stuff based on c/c++ and Windows */
#******************************************************************/

const
  FB_FALSE* {.importc, header: ibase_h.} = 0.cchar
  FB_TRUE* {.importc, header: ibase_h.} = 1.cchar

type
  #ISC_LONG* {.importc, header: ibase_h.} = int32
  #ISC_ULONG* {.importc, header: ibase_h.} = uint32
  #ISC_SHORT* {.importc, header: ibase_h.} = cshort
  #ISC_USHORT* {.importc, header: ibase_h.} = cushort
  #ISC_UCHAR* {.importc, header: ibase_h.} = cuchar
  #ISC_SCHAR* {.importc, header: ibase_h.} = cchar
  FB_BOOLEAN* {.importc, header: ibase_h.} = cuchar

#* 64 bit Integers                                                 */
#*******************************************************************/

#type
#ISC_INT64* {.importc, header: ibase_h.} = int64
#ISC_UINT64* {.importc, header: ibase_h.} = uint64

#* Time & Date support                                             */
#*******************************************************************/

type
  DATE* {.importc: "ISC_DATE", header: ibase_h.} = cint
  TIME* {.importc: "ISC_TIME", header: ibase_h.} = cuint

  TIMESTAMP* {.importc: "ISC_TIMESTAMP", header: ibase_h.} = object
    timestamp_date*: DATE
    timestamp_time*: TIME

#* Blob Id support                                                 */
#*******************************************************************/

type
  QUAD_t* {.importc: "GDS_QUAD", header: ibase_h.} = object
    # NB these were aliased from isc_quad_*, but nim doesn't have #define
    gds_quad_high*: int32
    gds_quad_low*: uint32

  GDS_QUAD* = QUAD_t
  ISC_QUAD* = QUAD_t

  FB_SHUTDOWN_CALLBACK* {.importc, header: ibase_h.} = proc(reason, mask: cint; arg: pointer): cint

#* Firebird Handle Definitions */
#********************************/

type
  att_handle* = FB_API_HANDLE
  blob_handle* = FB_API_HANDLE
  db_handle* = FB_API_HANDLE
  req_handle* = FB_API_HANDLE
  stmt_handle* = FB_API_HANDLE
  svc_handle* = FB_API_HANDLE
  tr_handle* = FB_API_HANDLE
  resv_handle* = int32

  callback* {.importc: "isc_callback", header: ibase_h.} = proc()
  PRINT_CALLBACK* {.importc: "ISC_PRINT_CALLBACK", header: ibase_h.} = proc(a: pointer; b: cshort; c: cstring)
  VERSION_CALLBACK* {.importc: "ISC_VERSION_CALLBACK", header: ibase_h.} = proc(a: pointer; b: cstring)
  EVENT_CALLBACK* {.importc: "ISC_EVENT_CALLBACK", header: ibase_h.} = proc(a: pointer; b: cushort; c: ptr cuchar)

#* Blob id structure                                               */
#*******************************************************************/

type
  ARRAY_BOUND* {.importc: "ISC_ARRAY_BOUND", header: ibase_h.} = object
    array_bound_lower*: cshort
    array_bound_upper*: cshort

  ARRAY_DESC* {.importc: "ISC_ARRAY_DESC", header: ibase_h.} = object
    array_desc_dtype*: cuchar
    array_desc_scale*: cchar
    array_desc_length*: cushort
    array_desc_field_name*: array[0..31, cchar]
    array_desc_relation_name*: array[0..31, cchar]
    array_desc_dimensions*: cshort
    array_desc_flags*: cshort
    array_desc_bounds*: array[0..15, ARRAY_BOUND]

  BLOB_DESC* {.importc: "ISC_BLOB_DESC", header: ibase_h.} = object
    blob_desc_subtype*: cshort
    blob_desc_charset*: cshort
    blob_desc_segment_size*: cshort
    blob_desc_field_name*: array[0..31, cuchar]
    blob_desc_relation_name*: array[0..31, cuchar]

#* Blob control structure  */
#***************************/

type
  blob_ctl_obj* {.importc: "struct isc_blob_ctl", header: ibase_h.} = object
    ctl_source*: proc(): STATUS
    ctl_source_handle*: ptr blob_ctl_obj
    ctl_to_sub_type*: cshort
    ctl_from_sub_type*: cshort
    ctl_buffer_length*: cushort
    ctl_segment_length*: cushort
    ctl_bpb_length*: cushort
    ctl_bpb*: cstring
    ctl_buffer*: ptr cuchar
    ctl_max_segment*: int32
    ctl_number_segments*: int32
    ctl_total_length*: int32
    ctl_status*: ptr STATUS
    ctl_data*: array[0..7, int32]

  BLOB_CTL* = ptr blob_ctl_obj

#* Blob stream definitions */
#***************************/

type
  BSTREAM* {.importc: "struct bstream", header: ibase_h.} = object
    bstr_blob*: blob_handle
    bstr_buffer*: cstring
    bstr_ptr*: cstring
    bstr_length*: cshort
    bstr_cnt*: cshort
    bstr_mode*: cchar

  FB_BLOB_STREAM* = ptr BSTREAM

#define getb(p) (--(p)->bstr_cnt >= 0 ? *(p)->bstr_ptr++ & 0377: BLOB_get (p))
#define putb(x, p) (((x) == '\n' || (!(--(p)->bstr_cnt))) ? BLOB_put ((x),p) : ((int) (*(p)->bstr_ptr++ = (unsigned) (x))))
#define putbx(x, p) ((!(--(p)->bstr_cnt)) ? BLOB_put ((x),p) : ((int) (*(p)->bstr_ptr++ = (unsigned) (x))))

type
  blob_lseek_mode* {.importc, header: ibase_h.} = cint
const
  blb_seek_relative* = 1
  blb_seek_from_tail* = 2

type
  blob_get_result* {.importc, header: ibase_h.} = cint
const
  blb_got_fragment* = -1
  blb_got_eof* = 0
  blb_got_full_segment* = 1

type
  blobcallback_obj* {.importc: "struct blobcallback", header: ibase_h.} = object
    blob_get_segment*: proc(hnd: pointer; buffer: ptr cuchar; buf_size: cushort; result_len: ptr cushort): cshort
    blob_handle*: pointer
    blob_number_segments*: int32
    blob_max_segment*: int32
    blob_total_length*: int32
    blob_put_segment*: proc(hnd: pointer; buffer: ptr cuchar; buf_size: cushort)
    blob_lseek*: proc(hnd: pointer; mode: cushort; offset: int32): int32

  BLOBCALLBACK* = ptr blobcallback_obj

  PARAMDSC* {.importc, header: ibase_h.} = object
    dsc_dtype*: cuchar
    dsc_scale*: int8
    dsc_length*: cushort
    dsc_sub_type*: cshort
    dsc_flags*: cushort
    dsc_address*: ptr cuchar

  PARAMVARY* {.importc, header: ibase_h.} = object
    vary_length*: cushort
    vary_string*: array[0..0, cuchar]

const
  DSC_null*        = 1
  DSC_no_subtype*  = 2
  DSC_nullable*    = 4
  dtype_unknown*   = 0
  dtype_text*      = 1
  dtype_cstring*   = 2
  dtype_varying*   = 3
  dtype_packed*    = 6
  dtype_byte*      = 7
  dtype_short*     = 8
  dtype_long*      = 9
  dtype_quad*      = 10
  dtype_real*      = 11
  dtype_double*    = 12
  dtype_d_float*   = 13
  dtype_sql_date*  = 14
  dtype_sql_time*  = 15
  dtype_timestamp* = 16
  dtype_blob*      = 17
  dtype_array*     = 18
  dtype_int64*     = 19
  dtype_dbkey*     = 20
  dtype_boolean*   = 21
  DTYPE_TYPE_MAX*  = 22
  TIME_SECONDS_PRECISION*       = 10000
  TIME_SECONDS_PRECISION_SCALE* = -4

#* Dynamic SQL definitions */
#***************************/

type
  # SK: turned in to an enum for nimization
  StatementFreeType* = enum
    DSQL_close      = 1
    DSQL_drop       = 2
    DSQL_unprepare  = 4

const
  SQLDA_VERSION1*  = 1

type
  XSQLVAR* {.importc, header: ibase_h.} = object
    sqltype*: cshort
    sqlscale*: cshort
    sqlsubtype*: cshort
    sqllen*: cshort
    sqldata*: pointer
    sqlind*: ptr cshort
    sqlname_length*: cshort
    sqlname*: array[0..31, cchar]
    relname_length*: cshort
    relname*: array[0..31, cchar]
    ownname_length*: cshort
    ownname*: array[0..31, cchar]
    aliasname_length*: cshort
    aliasname*: array[0..31, cchar]

  PXSQLVAR* = ptr XSQLVAR

  XSQLDA* {.importc, header: ibase_h.} = object
    version*: cshort
    sqldaid*: array[0..7, cchar]
    sqldabc*: int32
    sqln*: cshort # number of parameters allocated
    sqld*: cshort # number of parameters firebird wants to use
    sqlvar*: array[0..0, XSQLVAR]

  PXSQLDA* = ptr XSQLDA

const
  SQL_TEXT*                       =   452
  SQL_VARYING*                    =   448
  SQL_SHORT*                      =   500
  SQL_LONG*                       =   496
  SQL_FLOAT*                      =   482
  SQL_DOUBLE*                     =   480
  SQL_D_FLOAT*                    =   530
  SQL_TIMESTAMP*                  =   510
  SQL_BLOB*                       =   520
  SQL_ARRAY*                      =   540
  SQL_QUAD*                       =   550
  SQL_TYPE_TIME*                  =   560
  SQL_TYPE_DATE*                  =   570
  SQL_INT64*                      =   580
  SQL_BOOLEAN*                    = 32764
  SQL_NULL*                       = 32766
  SQL_DATE*                       =   SQL_TIMESTAMP

template XSQLDA_LENGTH*(n: int): int =
  XSQLDA.sizeof + ((n - 1) * XSQLVAR.sizeof)

proc `[]`* (self: PXSQLDA; index: int): PXSQLVAR =
  # bounds checking
  assert index >= 0
  assert index < self.sqln
  # return the thing
  var x = cast[int](unsafeaddr self.sqlvar[0])
  inc x, (XSQLVAR.sizeof) * index
  result = cast[PXSQLVAR](x)

proc make_xsqlda*(vars: int): PXSQLDA =
  result = cast[PXSQLDA](alloc(XSQLDA_LENGTH(vars)))
  result.version = SQLDA_VERSION1
  result.sqln = vars.cshort
  result.sqld = vars.cshort

proc free*(self: PXSQLDA; dealloc_children: bool = true) =
  # free potentially allocated data; if you are doing cheeky things,
  # like using pointers to local value buffers, you will want this to
  # be false.
  if dealloc_children:
    for i in 0..<self.sqln:
      let here = self[i]
      if here.sqldata != nil:
        dealloc(here.sqldata)
      if here.sqlind != nil:
        dealloc(here.sqlind)
  # now ditch the object
  dealloc(self)

template connect*(self: PXSQLDA; index: int; value: ptr int32; ind: ptr cshort) =
  assert index >= 0
  assert index < self.sqln
  let here = self[index]
  here.sqltype = SQL_LONG + 1
  here.sqllen = 4
  here.sqldata = value
  here.sqlind = ind

template connect_char*(self: PXSQLDA; index: int; value: var string; ind: ptr cshort) =
  assert index >= 0
  assert index < self.sqln
  let here = self[index]
  here.sqltype = SQL_TEXT + 1
  here.sqllen = value.len.int16
  here.sqldata = value[0].addr
  here.sqlind = ind

template connect_varchar*(self: PXSQLDA; index: int; value: var string; ind: ptr cshort) =
  assert index >= 0
  assert index < self.sqln
  let here = self[index]
  here.sqltype = SQL_VARYING + 1
  here.sqllen = value.len.int16 - cshort.sizeof.int16
  here.sqldata = value[0].addr
  here.sqlind = ind

proc `$`*(self: PXSQLVAR): string =
  case (self.sqltype - 1)
  of SQL_VARYING:
    let sl = cast[ptr cshort](self.sqldata)[]
    result = newstring(sl.int)
    for i in 0..<sl:
      # i'm sure this _totally_ won't become a performance issue someday
      result[i] = cast[ptr char](cast[int](self.sqldata)+i+cshort.sizeof)[]
  else:
    result = "<Unknown Firebird type.>"

#define XSQLDA_LENGTH(n)        (sizeof (XSQLDA) + (n - 1) * sizeof (XSQLVAR))


#* SQL Dialects            */
#***************************/

const
  SQL_DIALECT_V5*                = 1
  SQL_DIALECT_V6_TRANSITION*     = 2
  SQL_DIALECT_V6*                = 3
  SQL_DIALECT_CURRENT*           = SQL_DIALECT_V6

#* OSRI database functions */
#***************************/

proc attach_database(status: var STATUS_ARRAY; db_name_length: cshort; db_name: cstring; db: var db_handle; parm_buffer_length: cshort = 0; parm_buffer: cstring = nil): STATUS {.importc: "isc_attach_database", header: ibase_h.}

proc attach_database*(status_vector: var STATUS_ARRAY; db_name: cstring; db: var db_handle; parm_buffer_length: cshort = 0; parm_buffer: cstring = nil) {.inline.} =
  if attach_database(status_vector, 0, db_name, db, parm_buffer_length, parm_buffer) != 0:
    raise new_firebird_exception(status_vector)

# TODO STATUS isc_array_gen_sdl(status: var STATUS_ARRAY, const ARRAY_DESC*, cshort*, cuchar*, cshort*);

proc array_get_slice_inner(status: var STATUS_ARRAY; db: var db_handle; transaction: var tr_handle; array_id: var QUAD_t; desc: var ARRAY_DESC; buf: pointer; buflen: var int32): STATUS {.importc: "isc_array_get_slice", header: ibase_h.}

proc array_get_slice*(status: var STATUS_ARRAY; db: var db_handle; transaction: var tr_handle; array_id: var QUAD_t; desc: var ARRAY_DESC; buf: pointer; buflen: var int32) {.inline.} =
  if array_get_slice_inner(status, db, transaction, array_id, desc, buf, buflen) != 0:
    raise new_firebird_exception(status)

proc array_lookup_bounds_inner(status: var STATUS_ARRAY; db: var db_handle; transaction: var tr_handle; table_name, column_name: cstring; desc: var ARRAY_DESC): STATUS {.importc: "isc_array_lookup_bounds", header: ibase_h.}

proc array_lookup_bounds*(status: var STATUS_ARRAY; db: var db_handle; transaction: var tr_handle; table_name, column_name: cstring; desc: var ARRAY_DESC) {.inline.} =
  if array_lookup_bounds_inner(status, db, transaction, table_name, column_name, desc) != 0:
    raise new_firebird_exception(status)

# TODO STATUS isc_array_lookup_desc(status: var STATUS_ARRAY, db: var db_handle, transaction: var tr_handle, const cstring, const cstring, ARRAY_DESC*);
# TODO STATUS isc_array_set_desc(status: var STATUS_ARRAY, const cstring, const cstring, const short*, const short*, const short*, ARRAY_DESC*);

proc array_put_slice_inner(status: var STATUS_ARRAY; db: var db_handle; transaction: var tr_handle; array_id: var QUAD_t; desc: var ARRAY_DESC; buf: pointer; buflen: var int32): STATUS {.importc: "isc_array_put_slice", header: ibase_h.}

proc array_put_slice*(status: var STATUS_ARRAY; db: var db_handle; transaction: var tr_handle; array_id: var QUAD_t; desc: var ARRAY_DESC; buf: pointer; buflen: var int32) {.inline.} =
  if array_put_slice_inner(status, db, transaction, array_id, desc, buf, buflen) != 0:
    raise new_firebird_exception(status)

# TODO void isc_blob_default_desc(BLOB_DESC*, const cuchar*, const cuchar*);
# TODO STATUS isc_blob_gen_bpb(status: var STATUS_ARRAY, const BLOB_DESC*, const BLOB_DESC*, unsigned short, cuchar*, unsigned short*);
# TODO STATUS isc_blob_info(status: var STATUS_ARRAY, blob_handle*, short, const cstring, short, cstring);
# TODO STATUS isc_blob_lookup_desc(status: var STATUS_ARRAY, db: var db_handle, transaction: var tr_handle, const cuchar*, const cuchar*, BLOB_DESC*, cuchar*);
# TODO STATUS isc_blob_set_desc(status: var STATUS_ARRAY, const cuchar*, const cuchar*, short, short, short, BLOB_DESC*);
# TODO STATUS isc_cancel_blob(status: var STATUS_ARRAY, blob_handle *);

proc cancel_events_inner(status: var STATUS_ARRAY; db: var db_handle; event_id: var int32): STATUS {.importc: "isc_cancel_events", header: ibase_h.}

proc cancel_events*(status: var STATUS_ARRAY; db: var db_handle; event_id: var int32) {.inline.} =
  if cancel_events_inner(status, db, event_id) != 0:
    raise new_firebird_exception(status)

proc close_blob_inner(status: var STATUS_ARRAY; blob: var blob_handle): STATUS {.importc: "isc_close_blob", header: ibase_h.}

proc close_blob*(status: var STATUS_ARRAY; blob: var blob_handle) {.inline.} =
  if close_blob_inner(status, blob) != 0:
    raise new_firebird_exception(status)

# TODO STATUS isc_commit_retaining(status: var STATUS_ARRAY, tr_handle *);
proc commit_transaction_inner(status: var STATUS_ARRAY; transaction: var tr_handle): STATUS {.importc: "isc_commit_transaction", header: ibase_h, discardable.}

proc commit_transaction*(status: var STATUS_ARRAY; transaction: var tr_handle) {.inline.} =
  if commit_transaction_inner(status, transaction) != 0:
    raise new_firebird_exception(status)

proc create_blob_inner(status: var STATUS_ARRAY; db: var db_handle; transaction: var tr_handle; blob: var blob_handle; blob_id: var QUAD_t): STATUS {.importc: "isc_create_blob", header: ibase_h.}

proc create_blob*(status: var STATUS_ARRAY; db: var db_handle; transaction: var tr_handle; blob: var blob_handle; blob_id: var QUAD_t) {.inline.} =
  if create_blob_inner(status, db, transaction, blob, blob_id) != 0:
    raise new_firebird_exception(status)

proc create_blob_inner(status: var STATUS_ARRAY, db: var db_handle, transaction: var tr_handle; blob: var blob_handle; blob_id: var QUAD_t; bpb_len: cshort; bpb: cstring): STATUS {.importc: "isc_create_blob2", header: ibase_h.}

proc create_blob*(status: var STATUS_ARRAY, db: var db_handle, transaction: var tr_handle; blob: var blob_handle; blob_id: var QUAD_t; bpb_len: cshort; bpb: cstring) {.inline.} =
  if create_blob_inner(status, db, transaction, blob, blob_id, bpb_len, bpb) != 0:
    raise new_firebird_exception(status)

# TODO STATUS isc_create_database(status: var STATUS_ARRAY, short, const cstring, db: var isc_db_handle, short, const cstring, short);
# TODO STATUS isc_database_info(status: var STATUS_ARRAY, db: var db_handle, short, const cstring, short, cstring);
# TODO void isc_decode_date(const QUAD_t*, pointer);
# TODO void isc_decode_sql_date(const DATE*, pointer);
# TODO void isc_decode_sql_time(const TIME*, pointer);
# TODO void isc_decode_timestamp(const TIMESTAMP*, pointer);

proc detach_database_inner(status: var STATUS_ARRAY, db: var db_handle): STATUS {.importc: "isc_detach_database", header: ibase_h, discardable.}

proc detach_database*(status: var STATUS_ARRAY, db: var db_handle) {.inline.} =
  if detach_database_inner(status, db) != 0:
    raise new_firebird_exception(status)

# TODO STATUS isc_drop_database(status: var STATUS_ARRAY_ARRAY, db: var db_handle);

proc dsql_allocate_statement_inner(status: var STATUS_ARRAY; db: var db_handle; statement: var stmt_handle): STATUS {.importc: "isc_dsql_allocate_statement", header: ibase_h.}

proc dsql_alloc_statement2_inner(status: var STATUS_ARRAY; db: var db_handle; statement: var stmt_handle): STATUS {.importc: "isc_dsql_alloc_statement2", header: ibase_h.}

proc dsql_allocate_statement*(status: var STATUS_ARRAY; db: var db_handle; statement: var stmt_handle; autofree: bool = true) {.inline.} =
  var derp: STATUS
  if autofree:
    derp = dsql_allocate_statement_inner(status, db, statement)
  else:
    derp = dsql_alloc_statement2_inner(status, db, statement)
  if derp != 0:
    raise new_firebird_exception(status)

proc dsql_describe_inner(status: var STATUS_ARRAY; statement: var stmt_handle; dialect: cushort = SQL_DIALECT_CURRENT; outx: ptr XSQLDA): STATUS {.importc: "isc_dsql_describe", header: ibase_h.}

proc dsql_describe*(status: var STATUS_ARRAY; statement: var stmt_handle; dialect: cushort = SQL_DIALECT_CURRENT; outx: ptr XSQLDA) {.inline.} =
  if dsql_describe_inner(status, statement, dialect, outx) != 0:
    raise new_firebird_exception(status)

proc dsql_describe_bind_inner(status: var STATUS_ARRAY; statement: var stmt_handle; dialect: cushort = SQL_DIALECT_CURRENT; inx: ptr XSQLDA): STATUS {.importc: "isc_dsql_describe_bind", header: ibase_h.}

proc dsql_describe_bind*(status: var STATUS_ARRAY; statement: var stmt_handle; dialect: cushort = SQL_DIALECT_CURRENT; inx: ptr XSQLDA) {.inline.} =
  if dsql_describe_bind_inner(status, statement, dialect, inx) != 0:
    raise new_firebird_exception(status)

proc dsql_exec_immed2_inner(status: var; db: var; transaction: var; statement_length: cushort; statement: cstring; dialect: cushort = SQL_DIALECT_CURRENT; inx, outx: ptr XSQLDA = nil): STATUS {.importc: "isc_dsql_exec_immed2", header: ibase_h.}

proc dsql_exec_immed2*(status: var; db: var; transaction: var; statement_length: cushort; statement: cstring; dialect: cushort = SQL_DIALECT_CURRENT; inx, outx: ptr XSQLDA = nil): STATUS {.inline.} =
  if dsql_exec_immed2_inner(status, db, transaction, 0, statement, dialect, inx, outx) != 0:
    raise new_firebird_exception(status)

proc dsql_execute_inner(status: var STATUS_ARRAY; transaction: var tr_handle; statement: var stmt_handle; dialect: cushort = SQL_DIALECT_CURRENT; xsql: ptr XSQLDA = nil): STATUS {.importc: "isc_dsql_execute", header: ibase_h.}

proc dsql_execute*(status: var STATUS_ARRAY; transaction: var tr_handle; statement: var stmt_handle; dialect: cushort; xsql: ptr XSQLDA) {.inline.} =
  if dsql_execute_inner(status, transaction, statement, dialect, xsql) != 0:
    raise new_firebird_exception(status)

proc dsql_execute_inner(status: var STATUS_ARRAY; transaction: var tr_handle; statement: var stmt_handle; dialect: cushort = SQL_DIALECT_CURRENT; inx, outx: ptr XSQLDA = nil): STATUS {.importc: "isc_dsql_execute2", header: ibase_h.}

proc dsql_execute*(status: var STATUS_ARRAY; transaction: var tr_handle; statement: var stmt_handle; dialect: cushort = SQL_DIALECT_CURRENT; inx, outx: ptr XSQLDA = nil) {.inline.} =
  if dsql_execute_inner(status, transaction, statement, dialect, inx, outx) != 0:
    raise new_firebird_exception(status)

proc dsql_execute_immediate(status: var STATUS_ARRAY; db: var db_handle; transaction: var tr_handle; length: cushort; query: cstring; dialect: cushort = SQL_DIALECT_CURRENT; xsql: ptr XSQLDA = nil): STATUS {.importc: "isc_dsql_execute_immediate", header: ibase_h.}

proc dsql_execute_immediate*(status: var STATUS_ARRAY; db: var db_handle; transaction: var tr_handle; query: cstring; dialect: cushort = SQL_DIALECT_CURRENT; xsql: ptr XSQLDA = nil) {.inline.} =
  if dsql_execute_immediate(status, db, transaction, 0, query, dialect, xsql) != 0:
    raise new_firebird_exception(status)

proc dsql_fetch_inner(status: var STATUS_ARRAY; statement: var stmt_handle; dialect: cushort = SQL_DIALECT_CURRENT; outx: ptr XSQLDA): STATUS {.importc: "isc_dsql_fetch", header: ibase_h.}

proc dsql_fetch*(status: var STATUS_ARRAY; statement: var stmt_handle; dialect: cushort = SQL_DIALECT_CURRENT; outx: ptr XSQLDA) {.inline.} =
  if dsql_fetch_inner(status, statement, dialect, outx) != 0:
    raise new_firebird_exception(status)

# TODO STATUS isc_dsql_finish(db: var db_handle);

proc dsql_free_statement_inner(status: var STATUS_ARRAY; statement: var stmt_handle; on_free: cushort): STATUS {.importc: "isc_dsql_free_statement", header: ibase_h.}

proc dsql_free_statement*(status: var STATUS_ARRAY; statement: var stmt_handle; on_free: StatementFreeType) {.inline.} =
  if dsql_free_statement_inner(status, statement, on_free.cushort) != 0:
    raise new_firebird_exception(status)

# TODO STATUS isc_dsql_insert(status: var STATUS_ARRAY, stmt_handle*, unsigned short, XSQLDA*);

proc dsql_prepare_inner(status: var STATUS_ARRAY; transaction: var tr_handle; statement_handle: var stmt_handle; statement_length: cushort; statement: cstring; dialect: cushort = SQL_DIALECT_CURRENT; xsql: ptr XSQLDA = nil): STATUS {.importc: "isc_dsql_prepare", header: ibase_h.}

proc dsql_prepare*(status: var STATUS_ARRAY; transaction: var tr_handle; statement_handle: var stmt_handle; statement: cstring; dialect: cushort = SQL_DIALECT_CURRENT; xsql: ptr XSQLDA = nil) {.inline.} =
  if dsql_prepare_inner(status, transaction, statement_handle, 0, statement, dialect, xsql) != 0:
    raise new_firebird_exception(status)

proc dsql_set_cursor_name_inner(status: var STATUS_ARRAY; statement: var stmt_handle; name: cstring; unused: cushort = 0): STATUS {.importc: "isc_dsql_set_cursor_name", header: ibase_h.}

proc dsql_set_cursor_name*(status: var STATUS_ARRAY; statement: var stmt_handle; name: cstring; unused: cushort = 0) {.inline.} =
  if dsql_set_cursor_name_inner(status, statement, name, unused) != 0:
    raise new_firebird_exception(status)

# TODO STATUS isc_dsql_sql_info(status: var STATUS_ARRAY, stmt_handle*, short, const cstring, short, cstring);
# TODO void isc_encode_date(const pointer, QUAD_t*);
# TODO void isc_encode_sql_date(const pointer, DATE*);
# TODO void isc_encode_sql_time(const pointer, TIME*);
# TODO void isc_encode_timestamp(const pointer, TIMESTAMP*);

proc event_block*(event_buf, result_buf: var cstring; name_count: cushort): int32 {.importc: "isc_event_block", header: ibase_h, varargs.}

# TODO cushort isc_event_block_a(cstring*, cstring*, cushort, cstring*);
# TODO void isc_event_block_s(cstring*, cstring*, cushort, cstring*, cushort*);
# TODO void isc_event_counts(uint32*, short, cuchar*, const cuchar *);
# TODO int isc_modify_dpb(cstring*, short*, unsigned short, const cstring, short); int32 isc_free(cchar *);

proc get_segment_inner(status: var STATUS_ARRAY; blob: var blob_handle; read_len: var cushort; blen: cushort; buf: ptr int8): STATUS {.importc: "isc_get_segment", header: ibase_h.}

proc get_segment*(status: var STATUS_ARRAY; blob: var blob_handle; read_len: var cushort; blen: cushort; buf: ptr int8) {.inline.} =
  if get_segment_inner(status, blob, read_len, blen, buf) != 0:
    raise new_firebird_exception(status)

# TODO STATUS isc_get_slice(status: var STATUS_ARRAY, db: var db_handle, transaction: var tr_handle, QUAD_t*, short, const cstring, short, const int32*, int32, pointer, int32*);
# TODO int32 fb_interpret(cstring, unsigned int, const status: var STATUS_ARRAY*);

proc open_blob_inner(status: var STATUS_ARRAY; db: var db_handle; transaction: var tr_handle; blob: var blob_handle; blob_id: var QUAD_t): STATUS {.importc: "isc_open_blob", header: ibase_h.}

proc open_blob*(status: var STATUS_ARRAY; db: var db_handle; transaction: var tr_handle; blob: var blob_handle; blob_id: var QUAD_t) {.inline.} =
  if open_blob_inner(status, db, transaction, blob, blob_id) != 0:
    raise new_firebird_exception(status)

# TODO STATUS isc_open_blob2(status: var STATUS_ARRAY, db: var db_handle, transaction: var tr_handle, blob_handle*, QUAD_t*, cushort, const cuchar*);

# TODO STATUS isc_prepare_transaction2(status: var STATUS_ARRAY, transaction: var tr_handle, cushort, const cuchar*);
# TODO void isc_print_sqlerror(cshort, const status: var STATUS_ARRAY);

proc print*(status: var STATUS_ARRAY): STATUS {.importc: "isc_print_status", header: ibase_h, discardable.}

proc put_segment_inner(status: var STATUS_ARRAY; blob: var blob_handle; blen: cushort; buf: ptr int8): STATUS {.importc: "isc_put_segment", header: ibase_h.}

proc put_segment*(status: var STATUS_ARRAY; blob: var blob_handle; blen: cushort; buf: ptr int8) {.inline.} =
  if put_segment_inner(status, blob, blen, buf) != 0:
    raise new_firebird_exception(status)

# TODO STATUS isc_put_slice(status: var STATUS_ARRAY, db: var db_handle, transaction: var tr_handle, QUAD_t*, short, const cstring, short, const int32*, int32, pointer);

proc que_events_inner(status: var STATUS_ARRAY; db: var db_handle; event_id: var int32; eblen: cshort; eb: cstring; cb: EVENT_CALLBACK; userdata: pointer): STATUS {.importc: "isc_que_events", header: ibase_h.}

proc que_events*(status: var STATUS_ARRAY; db: var db_handle; event_id: var int32; eblen: cshort; eb: cstring; cb: EVENT_CALLBACK; userdata: pointer) {.inline.} =
  if que_events_inner(status, db, event_id, eblen, eb, cb, userdata) != 0:
    raise new_firebird_exception(status)

# TODO STATUS isc_rollback_retaining(status: var STATUS_ARRAY, transaction: var tr_handle);

proc rollback_transaction_inner(status: var STATUS_ARRAY; transaction: var tr_handle): STATUS {.importc: "isc_rollback_transaction", header: ibase_h, discardable.}

proc rollback_transaction*(status: var STATUS_ARRAY; transaction: var tr_handle) {.inline.} =
  if rollback_transaction_inner(status, transaction) != 0:
    raise new_firebird_exception(status)

# TODO STATUS isc_start_multiple(status: var STATUS_ARRAY, transaction: var tr_handle, short, void *);

proc start_transaction_inner(status: var STATUS_ARRAY; transaction: var tr_handle; handle_count: cshort; db: var db_handle; tpb_length: cushort; tpb: cstring): STATUS {.importc: "isc_start_transaction", header: ibase_h,}

proc start_transaction*(status: var STATUS_ARRAY; transaction: var tr_handle; db: var db_handle; tpb_length: cushort = 0; tpb: cstring = nil) {.inline.} =
  if start_transaction_inner(status, transaction, 1.cshort, db, tpb_length, tpb) != 0:
    raise new_firebird_exception(status)

# TODO STATUS fb_disconnect_transaction(status: var STATUS_ARRAY, transaction: var tr_handle);

proc sqlcode*(status: var STATUS_ARRAY): int32 {.importc: "isc_sqlcode", header: ibase_h.}

# TODO void isc_sqlcode_s(const status: var STATUS_ARRAY, uint32*);
# TODO void fb_sqlstate(char*, const status: var STATUS_ARRAY);
# TODO void isc_sql_interprete(short, cstring, short);
# TODO STATUS isc_transaction_info(status: var STATUS_ARRAY, transaction: var tr_handle, short, const cstring, short, cstring);
# TODO STATUS isc_transact_request(status: var STATUS_ARRAY, db: var db_handle, transaction: var tr_handle, unsigned short, cstring, unsigned short, cstring, unsigned short, cstring);

proc vax_integer*(buf: pointer; size: cshort): int32 {.importc: "isc_vax_integer", header: ibase_h.}
proc portable_integer*(buf: pointer; size: cshort): int64 {.importc: "isc_portable_integer", header: ibase_h.}

#* Security Functions and structures */
#*************************************/

const
  sec_uid_spec* =                0x01
  sec_gid_spec* =                0x02
  sec_server_spec* =             0x04
  sec_password_spec* =           0x08
  sec_group_name_spec* =         0x10
  sec_first_name_spec* =         0x20
  sec_middle_name_spec* =        0x40
  sec_last_name_spec* =          0x80
  sec_dba_user_name_spec* =      0x100
  sec_dba_password_spec* =       0x200

  sec_protocol_tcpip* =          1
  sec_protocol_netbeui* =        2
  sec_protocol_spx* =            3
  sec_protocol_local* =          4

type
  USER_SEC_DATA* {.importc, header: ibase_h.} = object
    sec_flags*: cshort
    uid*: cint
    gid*: cint
    protocol*: cint
    server*: cstring
    user_name*: cstring
    password*: cstring
    group_name*: cstring
    first_name*: cstring
    middle_name*: cstring
    last_name*: cstring
    dba_user_name*: cstring
    dba_password*: cstring

proc add_user*(status: var STATUS_ARRAY; data: var USER_SEC_DATA): STATUS {.importc: "isc_add_user", header: ibase_h.}
proc delete_user*(status: var STATUS_ARRAY; data: var USER_SEC_DATA): STATUS {.importc: "isc_delete_user", header: ibase_h.}
proc modify_user*(status: var STATUS_ARRAY; data: var USER_SEC_DATA): STATUS {.importc: "isc_modify_user", header: ibase_h.}

#*  Other OSRI functions          */
#**********************************/

# TODO STATUS isc_compile_request(status: var STATUS_ARRAY, db: var db_handle, req_handle*, short, const cstring);
# TODO STATUS isc_compile_request2(status: var STATUS_ARRAY, db: var db_handle, req_handle*, short, const cstring);
# TODO STATUS isc_prepare_transaction(status: var STATUS_ARRAY, transaction: var tr_handle);
# TODO STATUS isc_receive(status: var STATUS_ARRAY, req_handle*, short, short, pointer, short);
# TODO STATUS isc_reconnect_transaction(status: var STATUS_ARRAY, db: var db_handle, transaction: var tr_handle, short, const cstring);
# TODO STATUS isc_release_request(status: var STATUS_ARRAY, req_handle*);
# TODO STATUS isc_request_info(status: var STATUS_ARRAY, req_handle*, short, short, const cstring, short, cstring);
# TODO STATUS isc_seek_blob(status: var STATUS_ARRAY, blob_handle*, short, int32, int32*);
# TODO STATUS isc_send(status: var STATUS_ARRAY, req_handle*, short, short, const pointer, short);
# TODO STATUS isc_start_and_send(status: var STATUS_ARRAY, req_handle*, transaction: var tr_handle, short, short, const pointer, short);
# TODO STATUS isc_start_request(status: var STATUS_ARRAY, req_handle *, tr_handle *, short);
# TODO STATUS isc_unwind_request(status: var STATUS_ARRAY, tr_handle *, short);

proc wait_for_event*(status: var STATUS_ARRAY; db: var db_handle; eb_len: cshort; event_buf, result_buf: cstring): STATUS {.importc: "isc_wait_for_event", header: ibase_h.}

#* Other Sql functions       */
#*****************************/

# TODO STATUS isc_close(status: var STATUS_ARRAY, const cstring);
# TODO STATUS isc_declare(status: var STATUS_ARRAY, const cstring, const cstring);
# TODO STATUS isc_describe(status: var STATUS_ARRAY, const cstring, XSQLDA *);
# TODO STATUS isc_describe_bind(status: var STATUS_ARRAY, const cstring, XSQLDA*);
# TODO STATUS isc_execute(status: var STATUS_ARRAY, transaction: var tr_handle, const cstring, XSQLDA*);
# TODO STATUS isc_execute_immediate(status: var STATUS_ARRAY, db: var db_handle, transaction: var tr_handle, short*, const cstring);
# TODO STATUS isc_fetch(status: var STATUS_ARRAY, const cstring, XSQLDA*);
# TODO STATUS isc_open(status: var STATUS_ARRAY, transaction: var tr_handle, const cstring, XSQLDA*);
# TODO STATUS isc_prepare(status: var STATUS_ARRAY, db: var db_handle, transaction: var tr_handle, const cstring, const short*, const cstring, XSQLDA*);

#* Other Dynamic sql functions       */
#*************************************/

# TODO STATUS isc_dsql_execute_m(status: var STATUS_ARRAY, transaction: var tr_handle, stmt_handle*, unsigned short, const cstring, unsigned short, unsigned short, cstring);
# TODO STATUS isc_dsql_execute2_m(status: var STATUS_ARRAY, transaction: var tr_handle, stmt_handle*, unsigned short, const cstring, unsigned short, unsigned short, cstring, unsigned short, cstring, unsigned short, unsigned short, cstring);
# TODO STATUS isc_dsql_execute_immediate_m(status: var STATUS_ARRAY, db: var db_handle, transaction: var tr_handle, unsigned short, const cstring, unsigned short, unsigned short, cstring, unsigned short, unsigned short, cstring);
# TODO STATUS isc_dsql_exec_immed3_m(status: var STATUS_ARRAY, db: var db_handle, transaction: var tr_handle, unsigned short, const cstring, unsigned short, unsigned short, cstring, unsigned short, unsigned short, const cstring, unsigned short, cstring, unsigned short, unsigned short, cstring);
# TODO STATUS isc_dsql_fetch_m(status: var STATUS_ARRAY, stmt_handle*, unsigned short, cstring, unsigned short, unsigned short, cstring);
# TODO STATUS isc_dsql_insert_m(status: var STATUS_ARRAY, stmt_handle*, unsigned short, const cstring, unsigned short, unsigned short, const cstring);
# TODO STATUS isc_dsql_prepare_m(status: var STATUS_ARRAY, transaction: var tr_handle, stmt_handle*, unsigned short, const cstring, unsigned short, unsigned short, const cstring, unsigned short, cstring);
# TODO STATUS isc_dsql_release(status: var STATUS_ARRAY, const cstring);
# TODO STATUS isc_embed_dsql_close(status: var STATUS_ARRAY, const cstring);
# TODO STATUS isc_embed_dsql_declare(status: var STATUS_ARRAY, const cstring, const cstring);
# TODO STATUS isc_embed_dsql_describe(status: var STATUS_ARRAY, const cstring, unsigned short, XSQLDA*);
# TODO STATUS isc_embed_dsql_describe_bind(status: var STATUS_ARRAY, const cstring, unsigned short, XSQLDA*);
# TODO STATUS isc_embed_dsql_execute(status: var STATUS_ARRAY, transaction: var tr_handle, const cstring, unsigned short, XSQLDA*);
# TODO STATUS isc_embed_dsql_execute2(status: var STATUS_ARRAY, transaction: var tr_handle, const cstring, unsigned short, XSQLDA*, XSQLDA*);
# TODO STATUS isc_embed_dsql_execute_immed(status: var STATUS_ARRAY, db: var db_handle, transaction: var tr_handle, unsigned short, const cstring, unsigned short, XSQLDA*);
# TODO STATUS isc_embed_dsql_fetch(status: var STATUS_ARRAY, const cstring, unsigned short, XSQLDA*);
# TODO STATUS isc_embed_dsql_fetch_a(status: var STATUS_ARRAY, int*, const cstring, cushort, XSQLDA*);
# TODO void isc_embed_dsql_length(const cuchar*, cushort*);
# TODO STATUS isc_embed_dsql_open(status: var STATUS_ARRAY, transaction: var tr_handle, const cstring, unsigned short, XSQLDA*);
# TODO STATUS isc_embed_dsql_open2(status: var STATUS_ARRAY, transaction: var tr_handle, const cstring, unsigned short, XSQLDA*, XSQLDA*);
# TODO STATUS isc_embed_dsql_insert(status: var STATUS_ARRAY, const cstring, unsigned short, XSQLDA*);
# TODO STATUS isc_embed_dsql_prepare(status: var STATUS_ARRAY, db: var db_handle, transaction: var tr_handle, const cstring, unsigned short, const cstring, unsigned short, XSQLDA*);
# TODO STATUS isc_embed_dsql_release(status: var STATUS_ARRAY, const cstring);

#* Other Blob functions       */
#******************************/

# TODO FB_BLOB_STREAM BLOB_open(blob_handle, cstring, int);
# TODO int BLOB_put(cchar, FB_BLOB_STREAM);
# TODO int BLOB_close(FB_BLOB_STREAM);
# TODO int BLOB_get(FB_BLOB_STREAM);
# TODO int BLOB_display(QUAD_t*, db_handle, tr_handle, const cstring);
# TODO int BLOB_dump(QUAD_t*, db_handle, tr_handle, const cstring);
# TODO int BLOB_edit(QUAD_t*, db_handle, tr_handle, const cstring);
# TODO int BLOB_load(QUAD_t*, db_handle, tr_handle, const cstring);
# TODO int BLOB_text_dump(QUAD_t*, db_handle, tr_handle, const cstring);
# TODO int BLOB_text_load(QUAD_t*, db_handle, tr_handle, const cstring);
# TODO FB_BLOB_STREAM Bopen(QUAD_t*, db_handle, tr_handle, const cstring);

#* Other Misc functions       */
#******************************/

# TODO int32 isc_ftof(const cstring, const unsigned short, cstring, const unsigned short);
# TODO STATUS isc_print_blr(const cstring, PRINT_CALLBACK, pointer, short);
# TODO int fb_print_blr(const cuchar*, uint32, PRINT_CALLBACK, pointer, short);
# TODO void isc_set_debug(int);
# TODO void isc_qtoq(const QUAD_t*, QUAD_t*);
# TODO void isc_vtof(const cstring, cstring, unsigned short);
# TODO void isc_vtov(const cstring, cstring, short);
# TODO int isc_version(db: var db_handle, VERSION_CALLBACK, pointer);
# TODO uintptr_t       isc_baddress(cstring);
# TODO void            isc_baddress_s(const cstring, uintptr_t*);

#* Service manager functions             */
#*****************************************/

#define ADD_SPB_LENGTH(p, length)       {*(p)++ = (length); \ *(p)++ = (length) >> 8;}

#define ADD_SPB_NUMERIC(p, data)        {*(p)++ = (cchar) (cuchar) (data); \ *(p)++ = (cchar) (cuchar) ((data) >> 8); \ *(p)++ = (cchar) (cuchar) ((data) >> 16); \ *(p)++ = (cchar) (cuchar) ((data) >> 24);}

# TODO STATUS isc_service_attach(status: var STATUS_ARRAY, unsigned short, const cstring, isc_svc_handle*, unsigned short, const cstring);
# TODO STATUS isc_service_detach(status: var STATUS_ARRAY, svc_handle *);
# TODO STATUS isc_service_query(status: var STATUS_ARRAY, svc_handle*, resv_handle*, unsigned short, const cstring, unsigned short, const cstring, unsigned short, cstring);
# TODO STATUS isc_service_start(status: var STATUS_ARRAY, svc_handle*, resv_handle*, unsigned short, const cstring);

#* Shutdown and cancel */
#***********************/

# TODO int fb_shutdown(unsigned int, const int);
# TODO STATUS fb_shutdown_callback(status: var STATUS_ARRAY, FB_SHUTDOWN_CALLBACK, const int, pointer);
# TODO STATUS fb_cancel_operation(status: var STATUS_ARRAY, db: var db_handle, cushort);

#* Ping the connection */
#***********************/

# TODO STATUS fb_ping(status: var STATUS_ARRAY, db: var db_handle);

#* Object interface */
#********************/

# TODO STATUS fb_get_database_handle(status: var STATUS_ARRAY, db: var db_handle, pointer);
# TODO STATUS fb_get_transaction_handle(status: var STATUS_ARRAY, transaction: var tr_handle, pointer);

#* Client information functions */
#********************************/

# TODO void isc_get_client_version ( cchar  *);
# TODO int  isc_get_client_major_version ();
# TODO int  isc_get_client_minor_version ();

#* Set callback for database crypt plugins */
#*******************************************/

# TODO STATUS fb_database_crypt_callback(status: var STATUS_ARRAY, pointer);

include private/constants
include private/status
#include private/errors
